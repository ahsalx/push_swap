## Project Description

This repository contains my implementation of the push_swap project from 42. The goal of the project is to sort a list of integers using only two stacks (a and b) and a limited set of operations, while keeping the number of moves as small as possible. The entire project is written in C.

To make the behavior of the program easier to understand, I also created visual guides and tools that show what happens internally during the sorting process.

---

## Sorting Algorithms

I use two different strategies depending on the size of the input:

### Small Inputs (≤ 5 numbers)

For small input sizes, I use a simple, hand-crafted sorting approach:

- For 2–3 numbers, I use a small set of conditions and operations to sort them directly.
- For 4–5 numbers, I use a sort_small function, which:
  - pushes the smallest elements to stack b,
  - sorts the remaining elements in stack a,
  - then pushes the elements from b back to a in the correct order.

This keeps the operation count low and is well suited for the small input constraints of the project.

### Larger Inputs (Radix Sort)

For larger input sizes, I use a binary radix sort adapted to the push_swap rules:

1. All values are converted to indices (from 0 to n-1) based on their sorted order.
2. The algorithm processes the numbers bit by bit, from the least significant bit to the most significant:
   - If the current bit of the number on top of a is 0, it is pushed to stack b.
   - If the bit is 1, the number is rotated within stack a.
3. After one full pass on a given bit, all elements from b are pushed back to a.
4. This process is repeated for each bit until the stack is fully sorted.

This gives an overall complexity of approximately O(n * log n), which works well for the big test cases in the project.

---

## Visual Guides and Function Trees

To help other people understand how the program works internally, I added several visual elements to the project:

- Function call trees that show what happens after each important function call.
- Step-by-step diagrams that explain:
  - how the arguments are parsed,
  - how the stacks are built,
  - how the small sort and radix sort behave,
  - how the program reaches the final sorted state.

These visuals act as a small guide for anyone reading the code or trying to learn the push_swap logic.

---

## Python Visualizer

I also created a Python visualizer that simulates the operations produced by push_swap and displays how the stacks change over time.

The visualizer:

- reads the list of operations generated by the push_swap program,
- applies them step by step,
- shows the content of stack a and stack b at each step,
- allows you to see how the algorithm moves and sorts the numbers.

I plan to record the visualizer in action and include it in the repository as a GIF so people can watch the sorting process without having to run the visualizer themselves.

---

## Programs

This project works with three programs/tools:

### push_swap (mandatory)
The main project program. It receives a list of integers and outputs the operations needed to sort them.

### checker (provided by 42)
Used to verify whether the sequence of operations generated by push_swap correctly sorts the input.

### visualizer.py (custom)
Python script that replays the operations produced by push_swap and visualizes how the values move between stack a and stack b.

---

## Usage

### Compile

```bash
make
```

### Run push_swap

```bash
./push_swap [numbers...]
```

### Use the Python visualizer

```bash
./push_swap [numbers...] | python3 visualizer.py [numbers...]
```

### Example (random 30 numbers)

Generate 30 random numbers, run `push_swap`, and check correctness with the official checker:

```bash
ARG=$(shuf -i 0-9999 -n 30 | tr '\n' ' ') && ./push_swap $ARG | ./checker_linux $ARG
```

If the sequence of operations correctly sorts the numbers, the checker will print:

```
OK
```

To visualize the same run with the Python visualizer:

```bash
ARG=$(shuf -i 0-9999 -n 30 | tr '\n' ' ') && ./push_swap $ARG | python3 visualizer.py $ARG
```

