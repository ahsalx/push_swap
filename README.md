## Project Description

This repository contains my implementation of the **push_swap** project from 42.  
The goal of the project is to sort a list of integers using only two stacks (`a` and `b`) and a limited set of operations, while keeping the number of moves as small as possible.  
The entire project is written in **C**.

To make the behavior of the program easier to understand, I also created visual guides and tools that show what happens internally during the sorting process.

---

## Sorting Algorithms

I use two different strategies depending on the size of the input:

### Small Inputs (≤ 5 numbers)

For small input sizes, I use a simple, hand-crafted sorting approach:

- For 2–3 numbers, I use a very small set of conditions and operations to sort them directly.
- For 4–5 numbers, I use a `sort_small` function, which:
  - pushes the smallest elements to stack `b`,
  - sorts the remaining elements in stack `a`,
  - then pushes the elements from `b` back to `a` in the correct order.

This keeps the operation count low and is well suited for the small input constraints of the project.

### Larger Inputs (Radix Sort)

For larger input sizes, I use a **binary radix sort** adapted to the push_swap rules:

1. All values are first converted to **indices** (from `0` to `n - 1`) based on their sorted order.  
2. The algorithm then processes the numbers **bit by bit**, from the least significant bit to the most significant:
   - If the current bit of the number on top of `a` is `0`, it is pushed to stack `b`.
   - If the bit is `1`, the number is rotated within stack `a`.
3. After one full pass on a given bit, all elements from `b` are pushed back to `a`.
4. This process is repeated for each bit until the stack is fully sorted.

This gives an overall complexity of approximately `O(n * log n)`, which works well for the big test cases in the project.

---

## Visual Guides and Function Trees

To help other people understand how the program works internally, I added several visual elements to the project:

- **Function call trees** that show what happens after each important function call.
- **Step-by-step diagrams** that explain:
  - how the arguments are parsed,
  - how the stacks are built,
  - how the small sort and radix sort behave,
  - how the program reaches the final sorted state.

These visuals act as a small guide for anyone reading the code or trying to learn the push_swap logic.

---

## Python Visualizer

I also created a **Python visualizer** that simulates the operations produced by `push_swap` and displays how the stacks change over time.

The visualizer:

- reads the list of operations generated by the `push_swap` program,
- applies them step by step,
- shows the content of stack `a` and stack `b` at each step,
- allows you to see how the algorithm moves and sorts the numbers.

I plan to record the visualizer in action and include it in the repository as a **GIF**, so people can watch the sorting process without having to run the visualizer themselves.
